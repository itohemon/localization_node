# パーティクルフィルタ（AMCL）ノードの実装概要
ノードの名前をparticle_localization_nodeとし、実装する主なステップとC++での処理を以下に示します。

## 1. ノードのセットアップとデータ受信
まずは必要なROS 2メッセージを受信するための準備をします。

|データ (ROS 2トピック)|処理内容|
|-|-|
|マップ (/map)|nav_msgs::msg::OccupancyGridをサブスクライブし、静的な環境情報をメモリに保持します。|
|オドメトリ (/odom)|nav_msgs::msg::Odometryをサブスクライブし、ロボットの相対的な移動量を取得します。|
|レーザースキャン (/scan)|sensor_msgs::msg::LaserScanをサブスクライブし、現在の観測データを取得します。|

C++では、rclcpp::Nodeを継承したクラスを作成し、これらのトピックのサブスクライバーを設定します。

## 2. パーティクルの定義と初期化
### A. パーティクル構造体
一つのパーティクル（粒子）は、ロボットの位置と姿勢、およびその重みを持つ必要があります。

```c++
struct Particle {
    double x, y, theta; // 姿勢 (Pose)
    double weight;       // 重み
};
// std::vector<Particle> particles; として管理
```

### B. 初期化
ノードの起動時や、ユーザーが指定した初期位置（例：RVizでの初期姿勢推定）を受け取った際に、パーティクルを初期化します。

- 既知の初期位置: 初期姿勢の周りに小さなガウスノイズを加えてパーティクルを分布させます。
- 未知の初期位置: マップ全体に均一にパーティクルをばらまきます。

## 3. パーティクルフィルタの核となる処理
パーティクルフィルタは、主に以下の3つのフェーズをオドメトリとスキャンデータが届くたびに繰り返します。

### 3.1. 予測（Prediction / Motion Update）
オドメトリが受信されるたびに実行します。

1. 前回のオドメトリと今回のオドメトリの差分（$\Delta x, \Delta y, \Delta \theta$）を計算します。
2. この差分にノイズ（Motion Model）を加えて、各パーティクルを移動させます。ロボットの移動には必ず誤差が伴うため、このノイズを加えることで、不確実性（広がり）を表現します。
$$\text{New\_pose} = \text{Old\_pose} + \text{Motion\_model}(\text{Odometry\_diff})$$

### 3.2. 更新（Update / Measurement Update）
レーザースキャンが受信されるたびに実行します。このステップで、各パーティクルの重みを計算します。

1. **観測モデル（Measurement Model）**を適用し、スキャンデータが地図とどれだけ一致するかを計算します。
- 方法: 各パーティクルの位置から仮想的なレーザーをマップ上に照射し、その結果（予測される距離）と、実際に受信したレーザーデータ（実測距離）を比較します。
2. 一致度が高いほど、パーティクルの重みが高くなります。一般的に、ガウス分布や指数分布などを用いて重みを計算します。
$$\text{Weight}_i \propto P(\text{Scan} \mid \text{Particle}_i)$$

### 3.3. リサンプリング（Resampling）
重みの計算後、一定の頻度で実行します。

1. 重みに応じて、パーティクルを再サンプリング（再抽出）します。
2. 重みの高いパーティクルは生き残り、重みの低いパーティクルは消滅しやすくなります。
3. これにより、確率の高い場所にパーティクルが集中し、推定の精度が向上します。これが「Monte Carlo」の部分です。

## 4. 結果のパブリッシュとTFブロードキャスト
### A. 最終姿勢の計算
リサンプリング後、すべてのパーティクルの重み付き平均を計算して、ロボットの最も確からしい姿勢を推定結果とします。

### B. ROS 2トピックのパブリッシュ
1. 姿勢パブリッシュ: 推定結果をgeometry_msgs::msg::PoseWithCovarianceStamped として /amcl_pose（AMCLの慣習）などのトピックにパブリッシュします。
2. パーティクルパブリッシュ: デバッグ用に、すべてのパーティクルの位置をgeometry_msgs::msg::PoseArray としてパブリッシュすると、RVizでパーティクルの分布を確認でき、学習に役立ちます。
### C. TFブロードキャスト
自己位置推定ノードの最も重要な役割の一つは、**map座標系からodom座標系への変換（$T_{map \rightarrow odom}$）**をブロードキャストすることです。
$$\text{map} \xrightarrow{T_{map \rightarrow odom}} \text{odom}$$

このTFをブロードキャストすることで、ナビゲーションスタック全体が、オドメトリ座標系での相対的な移動を、静的な地図座標系（map）内の絶対的な位置に変換できるようになります。tf2_ros::TransformBroadcasterを使用して実装します。

